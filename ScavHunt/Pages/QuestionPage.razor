@page "/q/{QuestionId}"
@using ScavHunt.Data.Models
@inject QuestionService questions;
@inject NavigationManager nav;
@inject LogService log;
@inject PlayerService players;
@inject PointService points;
@inject JSInterop js;
@inject MarkdownService md;

@if(State == QuestionState.Loading)
{
    <div class="container">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}
else if(question != default)
{
    <div class="container">
        <div class="row py-3 spacer">
            <div class="col-md-4 text-center my-auto text-primary">
                <h3>
                    @question.Title
                </h3>
                @if(incorrectCount > 0)
                {
                    <h5>@incorrectCount Incorrect Answers</h5>
                }
                @if(ElapsedTime >= TotalTime)
                {
                    <h5>@ElapsedTime.ToString("0.0+ sec")</h5>
                }
                else
                {
                    <h5>@ElapsedTime.ToString("0.0 sec")</h5>
                }
            </div>
            <div class="col-md">
                <h5 class="">@md.Render(question.Text)</h5>
            </div>
        </div>
        @if(State == QuestionState.LeadIn)
        {
            @for(int i = 0; i < 4; i++)
            {
                <div class="row bg-secondary choice py-3 my-0 @(i < 3 ? "spacer" : "")">
                    <div class="col justify-content-center d-flex">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
            }
        }
        @if (State == QuestionState.Active)
        {
            @for(int i = 0; i < DisplayChoices.Count; i++)
            {
                var index = i; // required for invoking ChoiceSelected properly

                var choice = DisplayChoices[index];
                var attempted = Attempted[index];

                <div class="row @(attempted ? "bg-danger" : "bg-secondary") cursor-pointer choice py-3 my-0 @(i < DisplayChoices.Count - 1 ? "spacer" : "")" @onclick="@(() => ChoiceSelected(index))">
                    <div class="col text-center my-auto">@choice</div>
                    <div class="col-auto arrow-bg mx-3 @(attempted ? "invisible" : "")">
                        <div class="arrow my-auto mx-auto">
                        </div>
                    </div>
                </div>
            }

            var displayedProgress = Math.Max(ProgressPercent(), 20);
        }
        @if(State == QuestionState.Success)
        {
            var answer = question.Answers.FirstOrDefault();
            var points = Points();
            @if (answer != null)
            {
                <div class="row bg-success choice py-3 my-0 spacer">
                    <div class="col text-center my-auto">@answer</div>
                </div>
            }
            <div class="row py-3">
                <h5 class="text-center">
                    You have earned @points points!
                </h5>
            </div>
            <div class="row">
                @md.Render(question.SuccessText)
            </div>
        }
        @if(State == QuestionState.EarlyLocked)
        {
            <div class="row bg-primary text-white choice py-3 my-0 spacer">
                <div class="col text-center my-auto">@($"You are {(question.UnlockTime - DateTime.Now).Humanize()} early!")</div>
            </div>
        }
        @if(State == QuestionState.LateLocked)
        {
            <div class="row bg-primary text-white choice py-3 my-0 spacer">
                <div class="col text-center my-auto">@($"This question has expired, you are {(DateTime.Now - question.LockTime).Humanize()} late.")</div>
            </div>
        }
    </div>
}

@code {
    const int DeltaTime = 100;

    QuestionState State { get; set; }
    enum QuestionState
    {
        Loading,
        LeadIn,
        Active,
        Success,
        EarlyLocked,
        LateLocked
    }

    [Parameter]
    public string QuestionId { get; set; }

    Question question{ get; set; }
    List<string> DisplayChoices { get; set; }
    List<bool> Attempted { get; set; }


    double TotalTime = 20;
    double ElapsedTime = 0;

    int incorrectCount { get; set; }

    Timer tickTimer;

    Player player;

    protected override async Task OnAfterRenderAsync(bool first)
    {
        if(!first)
        {
            return;
        }
        ElapsedTime = 0;

        player = await players.GetCurrent();

        if(player == default)
        {
            nav.NavigateTo("player");
            return;
        }

        question = await questions.GetFromShortCode(QuestionId);

        if(question == default)
        {
            nav.NavigateTo("404");
            return;
        }

        var succeededResponse = player.PointTransactions.FirstOrDefault(p => p.Question?.Id == question.Id);
        if(succeededResponse != default)
        {
            State = QuestionState.Success;
            StateHasChanged();
            return;
        }

        if (question.IsCurrentlyLockedEarly())
        {
            State = QuestionState.EarlyLocked;
            StateHasChanged();
            return;
        }

        if (question.IsCurrentlyLockedLate())
        {
            State = QuestionState.LateLocked;
            StateHasChanged();
            return;
        }

        if(question.Answers.Count == 0)
        {
            await Success();
            return;
        }

        if(player.Responses.Any(r => r.Type == LogRecord.RecordType.StartedQuestion && r.Question?.Id == question.Id))
        {
            ElapsedTime = TotalTime;
        }

        var incorrectResponses = player.Responses.Where(r => r.Type == LogRecord.RecordType.IncorrectAnswer && r.Question?.Id == question.Id);
        incorrectCount = incorrectResponses.Count();

        State = QuestionState.LeadIn;
        StateHasChanged();

        Attempted = new List<bool>();
        Attempted.AddRange(Enumerable.Repeat(false, question.Answers.Count));

        _ = Task.Run(async () =>
        {
            if (ElapsedTime == 0)
            {
                await Task.Delay(5000);
            }

            await log.Question(player, question, LogRecord.RecordType.StartedQuestion, $"Started question {question.ShortCode}.");

            if(question.ShuffleAnswers)
            {
                DisplayChoices = question.Answers.OrderBy(c => Random.Shared.Next()).ToList();
            }
            else
            {
                DisplayChoices = question.Answers.ToList();
            }

            State = QuestionState.Active;

            await InvokeAsync(StateHasChanged);

            tickTimer = new System.Threading.Timer(_ =>
            {
                Tick(DeltaTime);
            }, null, DeltaTime, DeltaTime);
        });   
    }

    async Task ChoiceSelected(int displayIndex)
    {
        if(State != QuestionState.Active)
        {
            return;
        }

        var choice = DisplayChoices[displayIndex];
        var index = question.Answers.IndexOf(choice);
        if(index == -1)
        {
            Console.WriteLine($"ERROR: Invalid choice selected on question {QuestionId} {choice}!");
            return;
        }

        if(index == 0)
        {
            await Success(choice);

            return;
        }
        if(index > 0 && index < Attempted.Count && !Attempted[displayIndex])
        {

            await log.Question(player, question, LogRecord.RecordType.IncorrectAnswer, $"Answered with {choice} instead of {question.Answers.FirstOrDefault()}.");

            incorrectCount++;

            Attempted[displayIndex] = true;
        }
    }

    async Task Success(string? choice = null)
    {
        State = QuestionState.Success;
        if(choice == null)
        {
            await log.Question(player, question, LogRecord.RecordType.CompletedQuestion, $"Awarded default for {Points()} points.");
        }
        else
        {   
            await log.Question(player, question, LogRecord.RecordType.CompletedQuestion, $"Answered with {choice} in {ElapsedTime.ToString("N2")} seconds  for {Points()} points.");
        }

        await points.AddPoints(player, question, Points());
        StopTimer();

        StateHasChanged();
    }

    int ProgressPercent()
    {
        return 100 - (int)(100 * (ElapsedTime / TotalTime));
    }

    void StopTimer()
    {
        tickTimer?.Change(Timeout.Infinite, Timeout.Infinite);
    }

    int Points()
    {
        return incorrectCount switch
        {
            0 => 5,
            1 => 4,
            2 => 2,
            3 => 1,
            _ => 0

        };
    }


    void Tick(int ms)
    {
        ElapsedTime += ms / 1000d;
        if(ElapsedTime >= TotalTime)
        {
            ElapsedTime = TotalTime;
            InvokeAsync(StopTimer);
        }
        InvokeAsync(StateHasChanged);
    }
}
